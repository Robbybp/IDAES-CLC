Property Models in IDAES
========================

This section discusses the implementation of models for calculating thermodynamic, transport and reaction properties within the IDAES framework, and how these can be integrated into models of unit operations.

.. contents:: Contents 
    :depth: 3

The vision for properties in IDAES is hat they will be generated by users for their specific systems and ranges of conditions, based on experimental data, using tools provided within the IDAES toolset. As such, most property calculations are expected to be specific to a given application, rather than general to a wide range of conditions. Due to this, property packages need only contain the property calculations necessary for the application for which they were developed, and developers should clearly document the purpose and contents of each model they develop.

Property Blocks
---------------

The approach for incorporating property calculations into unit models within the IDAES framework uses a modular structure based on Pyomo Blocks. Unit models make use of callable Python classes to construct Pyomo Block objects containing all the necessary variables and constraints for calculating a set of properties. These callable classes, and the blocks they construct, are referred to as **Property Packages** and are intended to be self contained, modular models for the properties of a given system.

Property Classes
^^^^^^^^^^^^^^^^

**Someone needs to add something here**

Contents of Property Classes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The contents of property packages and classes will vary somewhat depending on the purpose for which each package was developed. As property packages are expected to be developed for specific applications, a package need only contain calculations of the properties required by its target application. However, there are a number of items that all property packages should contain;

1. A header and metadata describing the details of the model, including;

	* Author and publication date,
	* Application of the model,
	* A list of components and the range of states the model is applicable for,
	* Source of the model equations, including (but not limited to) source data, fitting tools and methods, or literature sources.

2. A class named **_PropPack**, with the **ProcBlock** decorator which ultimately inherits from UnitModel in the IDAES core models (idaes_models.core.unit_model).
3. A component list (or lists) with standard names which is a member of the base class (_PropPack).
4. Documentation of how to use the model, and any arguments available in constructing the model.
5. An initialization routine for initializing the property package to an arbitrary state (within the range of applicability).

Inheriting from Property Classes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In some cases, it may be useful to build upon existing property classes in developing new property methods or extending the capabilities of existing packages. A good example of this would be for developing kinetic expression for a given system of reaction, which often need to build upon an underlying set of calculations for physical properties.

In these situations, modelers can inherit from an existing property package, which allows them to incorporate some or all of the capabilities of that package into their new package without the need to duplicate code. For the previous example, the developer of the kinetic model could inherit from an existing physical property package which contains the necessary physical properties and then add their new kinetic expressions on top of the previous model.

The advantage of doing this is to avoid duplicating code, however it also introduces potential conflicts as an update in the underlying model will affect the results of any model which inherits from it.

Integrating Properties into Models
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Variables associated with property blocks can be generally broken into two type; those that the unit model passes to the property block (e.g. states) and those that the unit model gets from the property block (most properties).

**State Variables**

For state variables, and any other variables that get passed from the unit model to the property block, it is generally necessary to duplicate the variable in the property block. This is because some models will have multiple states (e.g. multiphase system) and it is not possible to define standard naming conventions for the diverse possibilities of system configurations. Thus, property blocks should have their own set of state variables, which the user can then link to the necessary state variables in their unit models.


Currently, the simplest method for linking between state variables in the unit model and those in property blocks is by using equality constraints (e.g. :math:`T_{unit} = T_{property}`). in future developments of Pyomo it is hoped that better methods will become available.

**Property Variables**

In many cases, unit models can refer directly to the property values in their dependent property blocks within their constraints (e.g. a unit model could refer to *block.prop* within a constraint to link to the property *prop* from *block*). As long as the classes used to build the property blocks use the same naming convention for property names, property blocks should be easily interchangable.

Specific Models
---------------

A number of property packages are available for common property methods as part of the standard IDAES model library. Documentation for these property packages can be found below.

.. toctree::
    :maxdepth: 1

    cubiceos
