"""
Utility functions for implementing outer approximation with
jacobians calculated using automatic differentiation via CasADi.

Implementation of OA formulation given in...
[citation needed]

NOTE 2016-06-23: I have just updated the implementation of OA to be able to
generate the jacobians for pre-existing Constraint objects. This seems to be
a better idiom to stick with, so the old function calls are now deprecated.
"""
from __future__ import division
from __future__ import print_function
from pyomo.environ import Constraint, minimize, maximize, Set, Var, NonNegativeReals, Objective
from collections import Mapping, OrderedDict
import warnings
try:
    import casadi
    from casadi import SX, Function
except:
    warnings.warn("Cannot import casadi")
from math import copysign
from six import iterkeys, itervalues, iteritems
from six.moves import range

__author__ = "Qi Chen <qichen@andrew.cmu.edu>"

def add_indx_nonlinear_eq(constr, indx, pyo_vars, eq_expr, calc_jacs=True, jacs=None):
    """Adds a nonlinear equation with the given index (tuple) to the model constraint constr, generating and storing a corresponding CasADi jacobian in a dictionary for cut generation"""
    raise DeprecationWarning('This function is deprecated in preference of a new idiom given below. Comment out this line to continue using it.')
    name = constr.local_name

    def eq_rule():
        # combines the LHS expression generated by eq_expr with a zero RHS to form either a Pyomo or CasADi equality expression.
        LHS = eq_expr(*indx, **pyo_vars) if isinstance(indx, tuple) else eq_expr(indx, **pyo_vars)
        if LHS is Constraint.NoConstraint or LHS is Constraint.Skip:
            return Constraint.NoConstraint
        else:
            return LHS == 0

    eq_expression = eq_rule()
    if eq_expression is Constraint.NoConstraint:
        # Checks to see if the expression returned by the equation rule calls for skipping the constraint. If so, do that.
        return
    else:
        # Otherwise, add the expression to the indexed constraint
        constr.add(indx, expr=eq_rule())

    if not calc_jacs:
        # If we should add the constraint but not calculate the jacobian, then simply exit at this point.
        return

    new_constr = constr[indx]
    # Create dictionaries for CasADi variables and flattened variables
    cas_vars = {}
    flat_vars = {}

    for var_name, pyo_var in pyo_vars.iteritems():
        if isinstance(pyo_var, Mapping):
            # The passed value is not a variable, but rather a dictionary of variables. Flatten this dictionary appropriately.
            raise NotImplementedError()
        elif pyo_var.is_indexed():
            # if the pyomo variable is indexed, generate a dictionary of CasADi variables
            cas_vars[var_name] = {indx: SX.sym(var_name + '[' + str(indx) + ']') for indx in pyo_var._index}
            # At the same time, generate a dictionary of flattened variables (with the indices enumerated) for future use
            flat_vars.update({var_name + '[' + str(indx) + ']': (cas_vars[var_name][indx], pyo_var[indx]) for indx in pyo_var._index})
        else:
            # If the pyomo variable is not indexed, generate a single corresponding CasADi variable and add both to the flat variables dictionary
            cas_vars[var_name] = SX.sym(var_name)
            flat_vars[var_name] = (cas_vars[var_name], pyo_var)
    # Using the flat variables dictionary, generate a corresponding lists of CasADi variable names, CasADi variables and Pyomo (flattened) variables
    cas_var_name_list, var_list = zip(*flat_vars.iteritems())
    cas_var_list, pyo_var_list = zip(*var_list)

    f = eq_expr(*indx, **cas_vars) if isinstance(indx, tuple) else eq_expr(indx, **cas_vars)
    if f is Constraint.NoConstraint:
        # This would be a weird situation, where a non-indexed constraint returns a value indicating that no constraint is defined. In this case, nothing needs to be added to the jacobians dictionary.
        return
    # The options dictionary allows for more intuitive function calls later on. Note that the ordering of the CasADi variable name list matching the CasADi variable list is important.
    opt = {'input_scheme': cas_var_name_list, 'output_scheme': ['f']}
    # Generate a new CasADi function
    eqn = Function(name, cas_var_list, [f], opt)
    # Store the jacobian of the function with respect to each of the variables in an dictionary indexed by the corresponding Pyomo constraint. The stored value is an ordered dictionary so that the ordering of the variables will be preserved. This is important for future function calls.
    jacs[new_constr] = OrderedDict([(k, {'jac': eqn.jacobian(k, 'f'), 'var': flat_vars[k][1]}) for k in cas_var_name_list])

def get_jacobian(eqn, var_name, jacs=None):
    # Retrieve the jacobian for the current variable values of the constraint eqn for the variable denoted by var_name
    raise DeprecationWarning('This function is deprecated in preference of a new idiom given below. Comment out this line to continue using it.')
    return float(jacs[eqn][var_name]['jac'].call(map(lambda x: x['var'].value, jacs[eqn].values()))[0])

def add_indx_oa_cut(new_oa_iter, oa_constr, nl_constr, indx, slack_var, exists_var, disagg_vars={}, jacs=None, duals=None, obj_sense=None):
    raise DeprecationWarning('This function is deprecated in preference of a new idiom given below. Comment out this line to continue using it.')
    new_iter = new_oa_iter

    def getvar(var_name, var_entry):
        return var_entry['var'] if var_name not in disagg_vars else disagg_vars[var_name]

    constr = nl_constr[indx]
    jac_entry = jacs[constr]
    if indx is None:
        new_indx = new_iter
    elif isinstance(indx, tuple):
        new_indx = (new_iter,) + indx
    else:
        new_indx = (new_iter, indx)

    if obj_sense == minimize:
        sign_adjust = -1
    elif obj_sense == maximize:
        sign_adjust = 1
    else:
        raise ValueError('Unexpected objective sense: ' + obj_sense)

    oa_constr.add(
        new_indx,
        (None, copysign(1, sign_adjust * duals[constr]) * sum(get_jacobian(constr, var_name, jacs) * (getvar(var_name, var_entry) - getvar(var_name, var_entry).lb) for var_name, var_entry in jac_entry.iteritems()) - (copysign(1, sign_adjust * duals[constr]) * sum(get_jacobian(constr, var_name, jacs) * (var_entry['var'].value - getvar(var_name, var_entry).lb) for var_name, var_entry in jac_entry.iteritems()) * exists_var + slack_var[new_iter]), 0))

def apply_OA(nl_set, oa_block, jacs):
    """Applies outer approximation with augmented Lagrangian/equality relaxation scheme

    Args:
        equip (Block): Pyomo block for process unit description
        nl_set (set): Set of nonlinear constraints
        oa_block (Block): Pyomo block to hold generated OA cuts
        jacs (dict): dictionary in which to store jacobian information

    Returns:
        None

    Raises:
        ValueError: if a variable naming conflict exists
    """
    # Set up outer approximation iterations set
    oa_iter = oa_block.oa_iter = Set()
    for con_data in nl_set:
        if not con_data.active:
            continue  # if constraint is inactive, skip it
        # process this constraint
        var_dict = OrderedDict()
        # Build CasADi expression to mirror existing constraint
        f = process_constraint(con_data, var_dict)
        eqn = Function(
            # constr[indx].local_name,
            # TODO: need to figure out how to name function properly
            con_data.parent_component().local_name,
            [cas_var for pyo_var, cas_var in itervalues(var_dict)],
            [f],
            {'input_scheme': list(var_dict.keys()), 'output_scheme': ['f']})
        # Store the jacobian functions for future evaluation
        jacs[con_data] = {cname: eqn.jacobian(cname, 'f') for cname in iterkeys(var_dict)}
        if '_vars_' in jacs[con_data]:
            raise ValueError('Name conflict: cannot have a variable named "_vars_"')
        else:
            jacs[con_data]['_vars_'] = {
                pyo_var.local_name: pyo_var
                for pyo_var, cas_var in itervalues(var_dict)}

        # Generate empty constraints for holding OA constraints
        if not hasattr(oa_block, con_data.parent_component().local_name):
            if not con_data.parent_component().is_indexed():
                new_constr = Constraint(oa_iter)
            else:
                new_constr = Constraint(oa_iter, con_data.parent_component()._index)
            setattr(oa_block, con_data.parent_component().local_name, new_constr)
            # Generate slack variables
            new_slack_var = Var(oa_iter, domain=NonNegativeReals, initialize=0, bounds=(0, 1000))
            setattr(oa_block, '_slack_' + con_data.parent_component().local_name, new_slack_var)

def process_constraint(con_data, var_dict):
    expr = con_data.body
    if con_data.equality:
        # Constraint is an equality constraint
        assert con_data.upper == con_data.lower, 'Equality constraint should have equal upper and lower bounds.'
        return _process_expr(expr, var_dict) - con_data.upper
    else:
        # Constraint is an inequality constraint
        if con_data.lower is None:
            # we have a <= constraint
            return _process_expr(expr, var_dict) - con_data.upper
        elif con_data.upper is None:
            # we have a >= constraint. Rewrite in <= form.
            return -1 * _process_expr(expr, var_dict) + con_data.lower
        else:
            raise ValueError('Constraint miscategorized as inequality')

def _process_expr(expr, var_dict):
    if expr.is_constant():
        return expr.value
    from pyomo.core.base.var import _GeneralVarData
    if isinstance(expr, _GeneralVarData):
        # create a new CasADi variable if one doesn't already exist
        pyo_var, cas_var = var_dict.get(expr.local_name, (expr, None))
        if cas_var is None:
            cas_var = SX.sym(expr.local_name)
            var_dict[pyo_var.local_name] = (pyo_var, cas_var)
        return cas_var
    from pyomo.core.base.expr import _SumExpression, _ProductExpression, _PowExpression, _IntrinsicFunctionExpression
    if isinstance(expr, _SumExpression):
        return sum(_process_expr(expr._args[i], var_dict) * expr._coef[i] for i in range(len(expr._args))) + expr._const
    if isinstance(expr, _ProductExpression):
        prod = expr._coef
        for num in expr._numerator:
            prod *= _process_expr(num, var_dict)
        for denom in expr._denominator:
            prod /= _process_expr(denom, var_dict)
        return prod
    if isinstance(expr, _PowExpression):
        return _process_expr(expr._args[0], var_dict) ** _process_expr(expr._args[1], var_dict)
    if isinstance(expr, _IntrinsicFunctionExpression):
        if expr._name == 'log':
            return casadi.log(_process_expr(expr._args[0], var_dict))
        if expr._name == 'exp':
            return casadi.exp(_process_expr(expr._args[0], var_dict))
        if expr._name == 'sqrt':
            return casadi.sqrt(_process_expr(expr._args[0], var_dict))
        # else: (We don't recognize the function)
        raise NotImplementedError('Unrecognized function: ' + expr._name)
    # else: (We don't recognize the expression)
    raise NotImplementedError('Unrecognized expression: ' + str(expr))

def add_oa_constraints(iter_num, oa_block, jacs, exists_var, disagg_vars={}):
    # Add new iteration to the set of iterations
    # print(oa_block.name)
    oa_block.oa_iter.add(iter_num)
    # Determine the objective sense value
    objs = oa_block.model().component_objects(ctype=Objective, active=True, descend_into=True)
    obj_sense = next(objs).sense
    if next(objs, None) is not None:
        raise NotImplementedError('Not sure how to handle dual values with multiple objectives. Unable to create OA cuts.')
    if obj_sense == minimize:
        sign_adjust = -1
    elif obj_sense == maximize:
        sign_adjust = 1
    else:
        raise ValueError('Unexpected objective sense: ' + obj_sense)

    def getvar(pyo_var):
        return disagg_vars.get(pyo_var.local_name, pyo_var)

    for con_data, jac_info in iteritems(jacs):
        con_name = con_data.parent_component().local_name
        oa_constr = getattr(oa_block, con_name)
        slack_var = getattr(oa_block, '_slack_' + con_name)
        if con_data.parent_component().is_indexed():
            # print(con_data.index())
            # con_data.parent_component().display()
            con_data_index = con_data.index()
            if not isinstance(con_data_index, tuple):
                con_data_index = (con_data_index,)
            indx = (iter_num,) + con_data_index
        else:
            indx = iter_num
        dual = oa_block.model().dual[con_data]
        oa_constr.add(
            indx,
            (None,
             copysign(1, sign_adjust * dual) *
             sum(_get_jacobian(con_data, name, jacs) *
                 (getvar(var) - getvar(var).lb)
                 for name, var in iteritems(jac_info['_vars_'])
                 ) -
             (copysign(1, sign_adjust * dual) * exists_var *
              sum(_get_jacobian(con_data, name, jacs) *
                  (var.value - getvar(var).lb)
                  for name, var in iteritems(jac_info['_vars_'])) +
              slack_var[iter_num]),
             0))

def _get_jacobian(constr, var_name, jacs):
    # Retrieve the jacobian for the current variable values of the constraint eqn for the variable denoted by var_name
    var_value_dict = {
        name: var.value for name, var in iteritems(jacs[constr]['_vars_'])}
    return float(
        jacs[constr][var_name](**var_value_dict)['df_d' + var_name])
